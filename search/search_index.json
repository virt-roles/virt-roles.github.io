{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Ansible roles for Linux KVM development Virtualization engineers often need to create specific environments for development and testing. Setting up host kernels, QEMU, libvirt, guest operating systems, and guest applications can be tedious and time-consuming. virt-roles is a collection of reusable Ansible roles for common operations. Each role takes input variables that control its behavior. For example, the following playbook creates a Fedora disk image: - hosts: kvm_hosts tasks: - name: install Fedora 33 disk image include_role: virt-builder-create-image vars: - os_version: fedora-33 - size: 32G - output: /var/lib/libvirt/images/fedora.img To get started, check out the tutorial . Chat with us at #virt-roles:matrix.org or contribute at virt-roles repository .","title":"Home"},{"location":"#ansible-roles-for-linux-kvm-development","text":"Virtualization engineers often need to create specific environments for development and testing. Setting up host kernels, QEMU, libvirt, guest operating systems, and guest applications can be tedious and time-consuming. virt-roles is a collection of reusable Ansible roles for common operations. Each role takes input variables that control its behavior. For example, the following playbook creates a Fedora disk image: - hosts: kvm_hosts tasks: - name: install Fedora 33 disk image include_role: virt-builder-create-image vars: - os_version: fedora-33 - size: 32G - output: /var/lib/libvirt/images/fedora.img To get started, check out the tutorial . Chat with us at #virt-roles:matrix.org or contribute at virt-roles repository .","title":"Ansible roles for Linux KVM development"},{"location":"qemu-from-source/","text":"Building QEMU from git sources The build-qemu role builds QEMU from git sources. The repository must be accessible via a local filename or git URL. See the build-qemu role documentation for details. Private GitLab repos Private GitLab repos require extra steps to enable access from machines without SSH keys: Create a Personal Access Token (PAS) with the read_repository scope. Specify the Personal Access Token in the git URL: - repo: https://USERNAME:PERSONAL_ACCESS_TOKEN@gitlab.com/USERNAME/REPO.git Be careful when embedding tokens in playbooks that you share with others! Ansible variables can be passed to ansible-playbook(1) to avoid hardcoding them in playbooks. For more options on handling secrets in Ansible, see this post .","title":"Building QEMU from git sources"},{"location":"qemu-from-source/#building-qemu-from-git-sources","text":"The build-qemu role builds QEMU from git sources. The repository must be accessible via a local filename or git URL. See the build-qemu role documentation for details.","title":"Building QEMU from git sources"},{"location":"qemu-from-source/#private-gitlab-repos","text":"Private GitLab repos require extra steps to enable access from machines without SSH keys: Create a Personal Access Token (PAS) with the read_repository scope. Specify the Personal Access Token in the git URL: - repo: https://USERNAME:PERSONAL_ACCESS_TOKEN@gitlab.com/USERNAME/REPO.git Be careful when embedding tokens in playbooks that you share with others! Ansible variables can be passed to ansible-playbook(1) to avoid hardcoding them in playbooks. For more options on handling secrets in Ansible, see this post .","title":"Private GitLab repos"},{"location":"qemu-rpm-installation/","text":"Installing QEMU from RPM packages QEMU RPMs that were built locally or maybe by a build service like Fedora's Koji can be installed as follows: - name: install qemu-kvm dnf: name: - https://build-service/.../qemu-kvm-6.1.0.x86_64.rpm - https://build-service/.../qemu-kvm-common-6.1.0.x86_64.rpm - https://build-service/.../qemu-kvm-core-6.1.0.x86_64.rpm - ... state: present allow_downgrade: yes # install even if newer rpms are already present disable_gpg_check: no # set to 'yes' if GPG key isn't installed","title":"Installing QEMU from RPM packages"},{"location":"qemu-rpm-installation/#installing-qemu-from-rpm-packages","text":"QEMU RPMs that were built locally or maybe by a build service like Fedora's Koji can be installed as follows: - name: install qemu-kvm dnf: name: - https://build-service/.../qemu-kvm-6.1.0.x86_64.rpm - https://build-service/.../qemu-kvm-common-6.1.0.x86_64.rpm - https://build-service/.../qemu-kvm-core-6.1.0.x86_64.rpm - ... state: present allow_downgrade: yes # install even if newer rpms are already present disable_gpg_check: no # set to 'yes' if GPG key isn't installed","title":"Installing QEMU from RPM packages"},{"location":"roles/","text":"Role Reference The following roles are available: build-kernel - build a Linux kernel from git sources with a given .config file. build-qemu - build QEMU from git sources. start-vm - start a libvirt domain from the given XML and wait for SSH. stop-vm - stop a libvirt domain. virt-builder-create-image - create a disk image file using virt-builder.","title":"Role Reference"},{"location":"roles/#role-reference","text":"The following roles are available: build-kernel - build a Linux kernel from git sources with a given .config file. build-qemu - build QEMU from git sources. start-vm - start a libvirt domain from the given XML and wait for SSH. stop-vm - stop a libvirt domain. virt-builder-create-image - create a disk image file using virt-builder.","title":"Role Reference"},{"location":"tutorial/","text":"Tutorial: A \"Hello World\" guest This tutorial walks through the creation of a guest and running \"Hello World\" inside the guest. This basic workflow can be used in many situations like reproducing bugs or running benchmarks. We will write an Ansible playbook and run it from the local machine. Ansible will connect to the host and guest over ssh and execute the playbook steps there. Installing Ansible Install Ansible: (local)$ sudo dnf install ansible From time to time Ansible features are deprecated so you may wish to build container images that combine a particular version of Ansible with your playbooks. This will ensure that your playbook executes successfully and without warnings in the future. Cloning virt-roles Clone the virt-roles git repository: (local)$ git clone https://github.com/virt-roles/virt-roles.git Make the roles available to Ansible by installing symlinks into ~/.ansible/roles/ : (local)$ mkdir -p ~/.ansible/roles (local)$ cd ~/.ansible/roles (local)$ for f in ~/virt-tasks/*; do test -d \"$f\" && ln -s \"$f\" .; done Playbooks can now include roles from virt-roles. Creating an Ansible inventory Ansible needs to know how to connect to the host and the guest (which we haven't created yet). This is done by specifying an Ansible inventory. Add ssh_config(1) Host entries for the host and the guest: (local)$ cat >>~/.ssh/config Host myhost Hostname myhost.f.q.d.n User root StrictHostKeyChecking no Host myguest Hostname 192.168.122.192 User root ProxyJump myhost StrictHostKeyChecking no ^D Here myhost.f.q.d.n is the fully-qualified domain name or IP address of the host. The guest IP address is 192.168.122.192, which may be the default IP address that libvirt assigns but you may need to adjust it for your system. The ProxyJump keyword specifies that myguest is reachable by sshing through myhost. This allows you to invoke ssh myguest to connect to the guest from your local machine. Create an Ansible inventory with ssh-config(1) Host aliases: (local)$ cat >hosts [hosts] myhost [guests] myguest ^D Creating a playbook Now that the inventory has been defined we can test that Ansible can run a simple playbook on the host: (local)$ cat >tutorial.yml --- - hosts: hosts tasks: - shell: echo \"Hello world from the host\" ^D (local)$ ansible-playbook -v -i hosts tutorial.yml ... TASK [shell] ********************************************************************************* changed: [myhost] => { \"changed\": true, \"cmd\": \"echo \\\"Hello world from the host\\\"\", \"delta\": \"0:00:00.002708\", \"rc\": 0, } STDOUT: Hello world from the host PLAY RECAP *********************************************************************************** myhost : ok=2 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 We can see that echo \"Hello world from the host\" was run on myhost. Creating a disk image Now we can create a guest using the virt-builder-create-image role . The tutorial.yml file should now look like this: --- - hosts: hosts tasks: - name: create disk image include_role: name: virt-builder-create-image vars: - os_version: fedora-34 - size: 64G - output: /var/lib/libvirt/images/myguest.img After running this playbook with ansible-playbook -i hosts tutorial.yml the disk image file will be located at /var/lib/libvirt/images/myguest.img on the host. Starting a virtual machine In order to create a virtual machine we need a disk image and libvirt domain XML that defines the virtual machine configuration. Writing libvirt domain XML from scratch is hard, but the virt-install(1) command can generate it for us: (myhost)# virt-install --import --name myguest --ram 2048 --disk path=/var/lib/libvirt/images/myguest.img,format=raw --os-variant fedora34 (myhost)# virsh dumpxml myguest ...XML... You can also dump the XML guests created with GNOME Boxes, virt-manager, or other tools on your local machine. Copy this XML into a file called files/myguest.xml so that the playbook can reference it. Once you have libvirt domain XML you can reuse it in other playbooks. You will not need to run virt-install(1) anymore. The start-vm role launches a guest from the given libvirt domain XML. Extend tutorial.yml so it now looks like this: --- - hosts: hosts tasks: - name: create disk image include_role: name: virt-builder-create-image vars: - os_version: fedora-34 - size: 64G - output: /var/lib/libvirt/images/myguest.img - name: start vm include_role: name: start-vm vars: - domain: test - xml: \"{{ lookup('file', 'files/myguest.xml') }}\" Note that you can template the libvirt domain XML using Ansible's lookup('template') feature . Template variables can be added into the \"start vm\" vars section. Run the playbook with ansible-playbook -i hosts tutorial.yml and the guest will be launched. Shut down the guest by running virsh shutdown myguest on the host. Running \"Hello World\" inside the guest Finally we can run \"Hello World\" inside the guest. Simply add another play to tutorial.yml that runs the command inside myguest and then stops the guest using the stop-vm role : --- - hosts: hosts tasks: - name: create disk image include_role: name: virt-builder-create-image vars: - os_version: fedora-34 - size: 64G - output: /var/lib/libvirt/images/myguest.img - name: start vm include_role: name: start-vm vars: - domain: test - xml: \"{{ lookup('file', 'files/myguest.xml') }}\" - hosts: vms tasks: - shell: echo \"Hello World from inside the guest\" - hosts: hosts tasks: - name: stop vm include_role: name: stop-vm vars: - domain: myguest Conclusion Our short Ansible playbook specified that a disk image file should be built and \"Hello World\" should be run inside the guest. This is the starting point for automating your virtualization workflows using virt-roles and Ansible. The playbook and libvirt domain XML files can be shared with others or published in a git repository. This will allow you to collaborate or simply version control your work. You may now wish to look at the Ansible roles that virt-roles provides here .","title":"Tutorial: A \"Hello World\" guest"},{"location":"tutorial/#tutorial-a-hello-world-guest","text":"This tutorial walks through the creation of a guest and running \"Hello World\" inside the guest. This basic workflow can be used in many situations like reproducing bugs or running benchmarks. We will write an Ansible playbook and run it from the local machine. Ansible will connect to the host and guest over ssh and execute the playbook steps there.","title":"Tutorial: A \"Hello World\" guest"},{"location":"tutorial/#installing-ansible","text":"Install Ansible: (local)$ sudo dnf install ansible From time to time Ansible features are deprecated so you may wish to build container images that combine a particular version of Ansible with your playbooks. This will ensure that your playbook executes successfully and without warnings in the future.","title":"Installing Ansible"},{"location":"tutorial/#cloning-virt-roles","text":"Clone the virt-roles git repository: (local)$ git clone https://github.com/virt-roles/virt-roles.git Make the roles available to Ansible by installing symlinks into ~/.ansible/roles/ : (local)$ mkdir -p ~/.ansible/roles (local)$ cd ~/.ansible/roles (local)$ for f in ~/virt-tasks/*; do test -d \"$f\" && ln -s \"$f\" .; done Playbooks can now include roles from virt-roles.","title":"Cloning virt-roles"},{"location":"tutorial/#creating-an-ansible-inventory","text":"Ansible needs to know how to connect to the host and the guest (which we haven't created yet). This is done by specifying an Ansible inventory. Add ssh_config(1) Host entries for the host and the guest: (local)$ cat >>~/.ssh/config Host myhost Hostname myhost.f.q.d.n User root StrictHostKeyChecking no Host myguest Hostname 192.168.122.192 User root ProxyJump myhost StrictHostKeyChecking no ^D Here myhost.f.q.d.n is the fully-qualified domain name or IP address of the host. The guest IP address is 192.168.122.192, which may be the default IP address that libvirt assigns but you may need to adjust it for your system. The ProxyJump keyword specifies that myguest is reachable by sshing through myhost. This allows you to invoke ssh myguest to connect to the guest from your local machine. Create an Ansible inventory with ssh-config(1) Host aliases: (local)$ cat >hosts [hosts] myhost [guests] myguest ^D","title":"Creating an Ansible inventory"},{"location":"tutorial/#creating-a-playbook","text":"Now that the inventory has been defined we can test that Ansible can run a simple playbook on the host: (local)$ cat >tutorial.yml --- - hosts: hosts tasks: - shell: echo \"Hello world from the host\" ^D (local)$ ansible-playbook -v -i hosts tutorial.yml ... TASK [shell] ********************************************************************************* changed: [myhost] => { \"changed\": true, \"cmd\": \"echo \\\"Hello world from the host\\\"\", \"delta\": \"0:00:00.002708\", \"rc\": 0, } STDOUT: Hello world from the host PLAY RECAP *********************************************************************************** myhost : ok=2 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 We can see that echo \"Hello world from the host\" was run on myhost.","title":"Creating a playbook"},{"location":"tutorial/#creating-a-disk-image","text":"Now we can create a guest using the virt-builder-create-image role . The tutorial.yml file should now look like this: --- - hosts: hosts tasks: - name: create disk image include_role: name: virt-builder-create-image vars: - os_version: fedora-34 - size: 64G - output: /var/lib/libvirt/images/myguest.img After running this playbook with ansible-playbook -i hosts tutorial.yml the disk image file will be located at /var/lib/libvirt/images/myguest.img on the host.","title":"Creating a disk image"},{"location":"tutorial/#starting-a-virtual-machine","text":"In order to create a virtual machine we need a disk image and libvirt domain XML that defines the virtual machine configuration. Writing libvirt domain XML from scratch is hard, but the virt-install(1) command can generate it for us: (myhost)# virt-install --import --name myguest --ram 2048 --disk path=/var/lib/libvirt/images/myguest.img,format=raw --os-variant fedora34 (myhost)# virsh dumpxml myguest ...XML... You can also dump the XML guests created with GNOME Boxes, virt-manager, or other tools on your local machine. Copy this XML into a file called files/myguest.xml so that the playbook can reference it. Once you have libvirt domain XML you can reuse it in other playbooks. You will not need to run virt-install(1) anymore. The start-vm role launches a guest from the given libvirt domain XML. Extend tutorial.yml so it now looks like this: --- - hosts: hosts tasks: - name: create disk image include_role: name: virt-builder-create-image vars: - os_version: fedora-34 - size: 64G - output: /var/lib/libvirt/images/myguest.img - name: start vm include_role: name: start-vm vars: - domain: test - xml: \"{{ lookup('file', 'files/myguest.xml') }}\" Note that you can template the libvirt domain XML using Ansible's lookup('template') feature . Template variables can be added into the \"start vm\" vars section. Run the playbook with ansible-playbook -i hosts tutorial.yml and the guest will be launched. Shut down the guest by running virsh shutdown myguest on the host.","title":"Starting a virtual machine"},{"location":"tutorial/#running-hello-world-inside-the-guest","text":"Finally we can run \"Hello World\" inside the guest. Simply add another play to tutorial.yml that runs the command inside myguest and then stops the guest using the stop-vm role : --- - hosts: hosts tasks: - name: create disk image include_role: name: virt-builder-create-image vars: - os_version: fedora-34 - size: 64G - output: /var/lib/libvirt/images/myguest.img - name: start vm include_role: name: start-vm vars: - domain: test - xml: \"{{ lookup('file', 'files/myguest.xml') }}\" - hosts: vms tasks: - shell: echo \"Hello World from inside the guest\" - hosts: hosts tasks: - name: stop vm include_role: name: stop-vm vars: - domain: myguest","title":"Running \"Hello World\" inside the guest"},{"location":"tutorial/#conclusion","text":"Our short Ansible playbook specified that a disk image file should be built and \"Hello World\" should be run inside the guest. This is the starting point for automating your virtualization workflows using virt-roles and Ansible. The playbook and libvirt domain XML files can be shared with others or published in a git repository. This will allow you to collaborate or simply version control your work. You may now wish to look at the Ansible roles that virt-roles provides here .","title":"Conclusion"},{"location":"why/","text":"Why and when to automate Software stacks are complex and setting them up manually is problematic. Think of how long it takes to configure a host, install a virtual machine, and get an application or benchmark running inside the guest. You are likely to make mistakes or accidentally skip steps, making this a frustrating experience. For many users setting up a virtual machine is a one-time task. Virtualization developers, on the other hand, need to do this constantly and it must be quick so they can stay productive. Automation solves this by creating a repeatable and reliable process that does not require human interaction. Ansible is a popular tool for automating IT infrastructure. Although it comes with built-in modules for many general-purpose operations, it can still be tricky to automate virtualization-specific operations. virt-roles provides ready-to-use Ansible roles for common operations that virtualization developers need. Using virt-roles can help you: Save time setting up virtual machines. Avoid mistakes when configuring complex software stacks. Share a specific development or test environment with others. Confidently re-run benchmarks or tests any time in the future. You can use virt-roles by writing your own Ansible playbooks , YAML files describing the desired state of the host, guest, and the virtual machine devices. Playbooks can be written in your favorite text editor or Integrated Development Environment (IDE). It is common to store playbooks in git repositories so they are version controlled and can be shared with others. Automation saves time when you expect to repeat the same thing again in the future or if you already automated something similar previously. If you are doing truly one-off tasks then automation may take longer than doing it manually.","title":"Why and when to automate"},{"location":"why/#why-and-when-to-automate","text":"Software stacks are complex and setting them up manually is problematic. Think of how long it takes to configure a host, install a virtual machine, and get an application or benchmark running inside the guest. You are likely to make mistakes or accidentally skip steps, making this a frustrating experience. For many users setting up a virtual machine is a one-time task. Virtualization developers, on the other hand, need to do this constantly and it must be quick so they can stay productive. Automation solves this by creating a repeatable and reliable process that does not require human interaction. Ansible is a popular tool for automating IT infrastructure. Although it comes with built-in modules for many general-purpose operations, it can still be tricky to automate virtualization-specific operations. virt-roles provides ready-to-use Ansible roles for common operations that virtualization developers need. Using virt-roles can help you: Save time setting up virtual machines. Avoid mistakes when configuring complex software stacks. Share a specific development or test environment with others. Confidently re-run benchmarks or tests any time in the future. You can use virt-roles by writing your own Ansible playbooks , YAML files describing the desired state of the host, guest, and the virtual machine devices. Playbooks can be written in your favorite text editor or Integrated Development Environment (IDE). It is common to store playbooks in git repositories so they are version controlled and can be shared with others. Automation saves time when you expect to repeat the same thing again in the future or if you already automated something similar previously. If you are doing truly one-off tasks then automation may take longer than doing it manually.","title":"Why and when to automate"}]}